<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>网络 on X̂ Blog</title><link>https://blog.xhat.org/tags/%E7%BD%91%E7%BB%9C/</link><description>Recent content in 网络 on X̂ Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 19 Sep 2023 23:34:26 +0800</lastBuildDate><atom:link href="https://blog.xhat.org/tags/%E7%BD%91%E7%BB%9C/index.xml" rel="self" type="application/rss+xml"/><item><title>OpenSSL 生成自签名证书</title><link>https://blog.xhat.org/posts/openssl-self-signed/</link><pubDate>Tue, 19 Sep 2023 23:34:26 +0800</pubDate><guid>https://blog.xhat.org/posts/openssl-self-signed/</guid><description>免费证书有效期一般较短，当服务器较多时，每个服务器都要安装脚本更新证书，管理起来比较麻烦。而合理使用自签名证书（比如测试或者非公开环境）也是不错的替代选择。
生成 CA 根证书 CA (Certificate Authority) 被称为证书授权中心，是数字证书发放和管理的机构。
根证书是 CA 认证中心给自己颁发的证书，是信任链的起始点。安装根证书意味着对这个 CA 认证中心的信任。
生成私钥 可以选择以下任何一种算法：
椭圆曲线（ECC）：
openssl ecparam -genkey -name secp384r1 -out ca.key 若需要加密私钥：
openssl ecparam -genkey -name secp384r1 | openssl ec -aes256 -out ca.key 其中 -name 参数指定使用的曲线，曲线名称可通过以下命令查看：
openssl ecparam -list_curves RSA：
openssl genrsa -out ca.key 4096 若需要加密私钥：
openssl genrsa -des3 -out ca.key 4096 生成根证书 使用上面的私钥生成一个证书，证书会包含一些组织信息和公钥。为了一劳永逸有效期自然越长越好，本例设置为 73000 天（20 年）。
如果是 RSA，可以使用 -sha256 签名。
openssl req -key ca.key -new -x509 -days 73000 -sha384 -subj &amp;#34;/C=CN/ST=Guangdong Province/L=Shenzhen/O=Shenzhen XXX Co.</description></item><item><title>获取 TCP 发送缓冲区信息</title><link>https://blog.xhat.org/posts/tcp-send-buffer/</link><pubDate>Thu, 04 May 2023 16:37:47 +0800</pubDate><guid>https://blog.xhat.org/posts/tcp-send-buffer/</guid><description>在大多数的网络编程情况下，是不需要特意关心 TCP 的缓冲区信息的。但在一些工业应用场景，如 RS485 转网口的数据采集，半双工的 485 不能同时进行读和写，这就要求 TCP 确认发送完一个指令后，才能发第二条。因为是总线网络，同时发送多条指令，对端回复数据将出现错乱。
当应用程序往套接字写入数据时，实际上只是写入了内核的发送缓冲区，接收方什么时候能收到报文是个未知数。
因此在某些需要同步状态的地方，发送方最好能确认对方收到报文后再做下一步动作。
Linux Linux 提供了 ioctl(fd, SIOCOUTQ, &amp;amp;count) 方法来查询一个套接字是否有未发送完成的数据。
SIOCOUTQ Returns the amount of unsent data in the socket send queue. The socket must not be in LISTEN state, otherwise an error (EINVAL) is returned. SIOCOUTQ is defined in &amp;lt;linux/sockios.h&amp;gt;. Alternatively, you can use the synonymous TIOCOUTQ, defined in &amp;lt;sys/ioctl.h&amp;gt;.
发送方可以使用这个方法来判断对端是否收到报文。以 Go 为例：
import ( &amp;#34;net&amp;#34; &amp;#34;golang.org/x/sys/unix&amp;#34; &amp;#34;unsafe&amp;#34; ) func getSendQueueLength(conn *net.</description></item><item><title>Linux 部署 WireGuard</title><link>https://blog.xhat.org/posts/linux-wireguard/</link><pubDate>Fri, 03 Sep 2021 14:33:27 +0800</pubDate><guid>https://blog.xhat.org/posts/linux-wireguard/</guid><description>安装 CentOS sudo yum install epel-release elrepo-release sudo yum install yum-plugin-elrepo sudo yum install kmod-wireguard wireguard-tools Ubuntu sudo apt install wireguard 若内核太老不想升级，可以使用 wireguard-go 代替。
配置 创建 Wireguard 目录： mkdir /etc/wireguard/ cd /etc/wireguard/ 生成密钥对 wg genkey | tee privatekey | wg pubkey &amp;gt; publickey 编辑配置文件 vi wg0.conf 内容模板：
[Interface] Address = 10.100.100.3/32 PrivateKey = KEY ListenPort = 21841 PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE [Peer] PublicKey = PUB Endpoint = IP AllowedIPs = 10.</description></item><item><title>Python 进行 ARP 欺骗</title><link>https://blog.xhat.org/posts/python-arpspoof/</link><pubDate>Wed, 09 Jun 2021 18:27:39 +0800</pubDate><guid>https://blog.xhat.org/posts/python-arpspoof/</guid><description>声明：本文所用的脚本仅限于学习测试目的，在使用中造成的一切后果与作者无关，后果自负。
ARP (Address Resolution Protocol) 即地址解析协议，是一种将 IP 地址转化成物理地址的协议。我们常用的以太网是通过 MAC 地址进行通信的，所以在网络链路上传送数据帧时，最终是使用硬件地址的。
一个典型的 ARP 流程如下表所示，这里为了叙述方便，硬件地址做了简化处理。
源地址 目的地址 内容 12:34:56 ff:ff:ff Who has 192.168.1.2? Tell 192.168.1.3 78:ab:cd 12:34:56 192.168.1.2 is at 78:ab:cd 大致流程就是12:34:56发送一个广播，问谁有某个 IP 地址，当对方收到这个广播时，如果自己的 IP 和广播里问的 IP 是一致的，就发送一个回复给提问者。这样提问者就建立了 IP 地址和物理地址的对应关系。
那如果对方不守信呢，明明自己没有这个 IP，还是坚持回复这个 IP 是自己，欺骗了提问者。这时提问者就会把数据包发给其他人，相当于数据包被人偷了！
没错，ARP 欺骗就是这个原理，可以用来做中间人攻击和拒绝服务攻击。下面分别实验一下两种情况。
网关 IP：10.1.45.254
受害者 IP：10.1.45.2
中间人攻击 欺骗受害者网关在我们这里，受害者就会把数据包发给我们，我们再代为转发给真正的网关，相当于做了一个中间人，这时我们可以捕获到受害者的通信数据包。
# arpspoof.py import sys from scapy.layers.l2 import Ether, ARP, sendp from scapy.layers.l2 import getmacbyip if __name__ == &amp;#39;__main__&amp;#39;: if len(sys.</description></item><item><title>OpenWrt + Pon Stick 配置教程</title><link>https://blog.xhat.org/posts/openwrt-pon-stick/</link><pubDate>Sat, 06 Feb 2021 14:00:28 +0800</pubDate><guid>https://blog.xhat.org/posts/openwrt-pon-stick/</guid><description>0x1 配置访问模块 首先确定模块插在哪个接口，本例中模块接在eth1上。确定模块IP，本例为192.168.1.1。下面配置一个接口，使内网的机器能直接访问模块。
若OpenWrt的地址也是192.168.1.1，需要修改地址： 在网络-&amp;gt;接口页面，编辑LAN接口，把IP地址改为172.20.0.1(其他网段亦可)。
新建一个接口，名字为PON，协议为静态IP，接口为eth1。 配置IP地址为192.168.1.2，子网掩码为255.255.255.252.
在防火墙设置选项卡里选择分配给wan，
后续就可以访问模块地址进行配置，请参考模块配置教程。
0x2 拨号 这部分已经假定模块已经配置完成，并完成光路认证。还需要确定VLAN ID，一般在光猫的后台可以看到：
在上网的连接名称可以看到后面的VID_41，41就是上网的VLAN ID。
回到OpenWrt页面，编辑WAN接口(没有的新建一个)，协议选择PPPoE，用户名密码照常输入，防火墙分配给wan. 要注意的是在物理设置选择接口那里，下拉到最后，在自定义输入框里输入eth1.41, eth1是模块所在的接口，41是上面的上网VLAN ID。
后续应该就可以正常拨号上网了。</description></item><item><title>OpenWrt 网关抓包</title><link>https://blog.xhat.org/posts/openwrt-trafficdump/</link><pubDate>Fri, 08 Jan 2021 11:26:10 +0800</pubDate><guid>https://blog.xhat.org/posts/openwrt-trafficdump/</guid><description>把 WireShark 添加到环境变量 OpenWrt 安装 tcpdump 执行命令:
ssh root@openwrt tcpdump -s 0 -U -n -w - -i eth1 not port 22 | wireshark -k -i - 注意将eth1替换为你实际需要捕获的接口。</description></item></channel></rss>