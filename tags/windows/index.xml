<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Windows on X̂ Blog</title><link>https://blog.xhat.org/tags/windows/</link><description>Recent content in Windows on X̂ Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 08 Feb 2022 15:36:31 +0800</lastBuildDate><atom:link href="https://blog.xhat.org/tags/windows/index.xml" rel="self" type="application/rss+xml"/><item><title>给 exe 添加文件信息</title><link>https://blog.xhat.org/posts/file-info-exe/</link><pubDate>Tue, 08 Feb 2022 15:36:31 +0800</pubDate><guid>https://blog.xhat.org/posts/file-info-exe/</guid><description>创建清单文件 文件名为manifest.xml。如果不需要管理器权限，就把trustInfo删掉。
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34; standalone=&amp;#34;yes&amp;#34;?&amp;gt; &amp;lt;assembly xmlns=&amp;#34;urn:schemas-microsoft-com:asm.v1&amp;#34; manifestVersion=&amp;#34;1.0&amp;#34;&amp;gt; &amp;lt;assemblyIdentity version=&amp;#34;1.0.0.0&amp;#34; processorArchitecture=&amp;#34;*&amp;#34; name=&amp;#34;app&amp;#34; type=&amp;#34;win32&amp;#34;/&amp;gt; &amp;lt;trustInfo xmlns=&amp;#34;urn:schemas-microsoft-com:asm.v2&amp;#34;&amp;gt; &amp;lt;security&amp;gt; &amp;lt;requestedPrivileges xmlns=&amp;#34;urn:schemas-microsoft-com:asm.v3&amp;#34;&amp;gt; &amp;lt;requestedExecutionLevel level=&amp;#34;requireAdministrator&amp;#34; uiAccess=&amp;#34;false&amp;#34; /&amp;gt; &amp;lt;/requestedPrivileges&amp;gt; &amp;lt;/security&amp;gt; &amp;lt;/trustInfo&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;dependentAssembly&amp;gt; &amp;lt;assemblyIdentity type=&amp;#34;win32&amp;#34; name=&amp;#34;Microsoft.Windows.Common-Controls&amp;#34; version=&amp;#34;6.0.0.0&amp;#34; processorArchitecture=&amp;#34;*&amp;#34; publicKeyToken=&amp;#34;6595b64144ccf1df&amp;#34; language=&amp;#34;*&amp;#34;/&amp;gt; &amp;lt;/dependentAssembly&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;application xmlns=&amp;#34;urn:schemas-microsoft-com:asm.v3&amp;#34;&amp;gt; &amp;lt;windowsSettings&amp;gt; &amp;lt;dpiAwareness xmlns=&amp;#34;http://schemas.microsoft.com/SMI/2016/WindowsSettings&amp;#34;&amp;gt;PerMonitorV2, PerMonitor&amp;lt;/dpiAwareness&amp;gt; &amp;lt;dpiAware xmlns=&amp;#34;http://schemas.microsoft.com/SMI/2005/WindowsSettings&amp;#34;&amp;gt;True&amp;lt;/dpiAware&amp;gt; &amp;lt;/windowsSettings&amp;gt; &amp;lt;/application&amp;gt; &amp;lt;/assembly&amp;gt; 创建资源文件 文件名为resources.rc，如果没有清单文件，可将对应的行删掉，图标文件类似。
#include &amp;lt;windows.h&amp;gt; #pragma code_page(65001) // UTF-8 #define STRINGIZE(x) #x #define EXPAND(x) STRINGIZE(x) LANGUAGE LANG_NEUTRAL, SUBLANG_NEUTRAL CREATEPROCESS_MANIFEST_RESOURCE_ID RT_MANIFEST manifest.xml 10 ICON EXPAND(APP_ICO) VS_VERSION_INFO VERSIONINFO FILEVERSION VERSION_ARRAY PRODUCTVERSION VERSION_ARRAY FILEFLAGSMASK VS_FFI_FILEFLAGSMASK FILEFLAGS 0x0 FILEOS VOS__WINDOWS32 FILETYPE VFT_APP FILESUBTYPE VFT2_UNKNOWN BEGIN BLOCK &amp;#34;StringFileInfo&amp;#34; BEGIN BLOCK &amp;#34;080404B0&amp;#34; BEGIN VALUE &amp;#34;CompanyName&amp;#34;, &amp;#34;Your Company&amp;#34; VALUE &amp;#34;FileDescription&amp;#34;, &amp;#34;Example&amp;#34; VALUE &amp;#34;FileVersion&amp;#34;, EXPAND(VERSION_STR) VALUE &amp;#34;InternalName&amp;#34;, &amp;#34;Example&amp;#34; VALUE &amp;#34;LegalCopyright&amp;#34;, &amp;#34;© example&amp;#34; VALUE &amp;#34;OriginalFilename&amp;#34;, &amp;#34;example.</description></item><item><title>Golang 程序以 Windows 服务运行</title><link>https://blog.xhat.org/posts/golang-windows-service/</link><pubDate>Fri, 12 Nov 2021 13:15:06 +0800</pubDate><guid>https://blog.xhat.org/posts/golang-windows-service/</guid><description>Windows 服务是运行后台程序的一个很好的选择，可以支持开机自动启动，程序异常退出后自动重启这些实用功能。
Windows 服务程序有一套自己的机制。如果你不想在你的程序添加任何代码的话，有一些工具可以直接把可执行程序作为 Windows 服务运行，比如 winsw。
本文介绍的是在 Go 中制作自己的服务程序，主要使用的是 golang.org/x/sys/windows/svc 这个包。正如文档所说，实现Handler接口即可，当服务启动时，会调用Execute方法。
type demoService struct { } func (service *demoService) Execute(args []string, r &amp;lt;-chan svc.ChangeRequest, changes chan&amp;lt;- svc.Status) (svcSpecificEC bool, exitCode uint32) { changes &amp;lt;- svc.Status{State: svc.StartPending} defer func() { changes &amp;lt;- svc.Status{State: svc.StopPending} log.Println(&amp;#34;Shutting down&amp;#34;) }() // 要执行的主程序代码 go yourMainFunc() changes &amp;lt;- svc.Status{State: svc.Running, Accepts: svc.AcceptStop | svc.AcceptShutdown} log.Println(&amp;#34;Startup complete&amp;#34;) for { select { case c := &amp;lt;-r: switch c.</description></item><item><title>Golang 在 Windows 下防止程序多开</title><link>https://blog.xhat.org/posts/golang-gui-singleton/</link><pubDate>Mon, 11 Oct 2021 11:02:41 +0800</pubDate><guid>https://blog.xhat.org/posts/golang-gui-singleton/</guid><description>当用户运行多个程序实例，如果操作的是同一资源，可能会造成数据不一致。所以有一个防止多开的需求，原理上是利用 CreateMutex 这个函数创建互斥对象。
func checkSingleton() (windows.Handle, error) { path, err := os.Executable() if err != nil { return 0, err } hashName := md5.Sum([]byte(path)) name, err := syscall.UTF16PtrFromString(&amp;#34;Local\\&amp;#34; + hex.EncodeToString(hashName[:])) if err != nil { return 0, err } return windows.CreateMutex(nil, false, name) } 检查error，如果是syscall.ERROR_ALREADY_EXISTS，则说明有一个程序已经在运行。
上面创建的互斥对象是局部的(有Local前缀)，多个用户登录还是可以同时多开程序的。如果需要全局限制，则替换为Global前缀。如果你的程序以服务的形式运行，则可能需要设置互斥对象的权限。
func checkSingleton() (windows.Handle, error) { path, err := os.Executable() if err != nil { panic(err) } hashName := md5.Sum([]byte(path)) name, err := syscall.UTF16PtrFromString(&amp;#34;Global\\&amp;#34; + hex.</description></item><item><title>Golang 打开 Windows 服务属性窗口</title><link>https://blog.xhat.org/posts/golang-service-property/</link><pubDate>Sun, 01 Aug 2021 11:35:17 +0800</pubDate><guid>https://blog.xhat.org/posts/golang-service-property/</guid><description>本文介绍如何在 Golang 程序里面打开某个 Windows 服务的属性窗口，这里需要用到 COM 接口，详细文档请参考 MMC 2.0 的官方文档。
既然是 COM 的话，程序里也可以使用cmd或者powershell来调用 COM 打开服务窗口。下面介绍直接调用 COM 组件的方法：
使用 github.com/go-ole/go-ole 这个库调用 COM：
import ( &amp;#34;github.com/go-ole/go-ole&amp;#34; &amp;#34;github.com/go-ole/go-ole/oleutil&amp;#34; &amp;#34;time&amp;#34; ) // 服务的显示名称 displayName := &amp;#34;Windows Update&amp;#34; ole.CoInitialize(0) unknown, _ := oleutil.CreateObject(&amp;#34;MMC20.Application&amp;#34;) mmc, _ = unknown.QueryInterface(ole.IID_IDispatch) // 读取服务 oleutil.MustCallMethod(mmc, &amp;#34;Load&amp;#34;, &amp;#34;services.msc&amp;#34;) document := oleutil.MustGetProperty(mmc, &amp;#34;Document&amp;#34;).ToIDispatch() view := oleutil.MustGetProperty(document, &amp;#34;ActiveView&amp;#34;).ToIDispatch() list := oleutil.MustGetProperty(view, &amp;#34;ListItems&amp;#34;).ToIDispatch() count := int(oleutil.MustGetProperty(list, &amp;#34;Count&amp;#34;).Val) // 注意索引从1开始 for i := 1; i &amp;lt;= count; i++ { item := oleutil.</description></item><item><title>Windows 创建临时文件</title><link>https://blog.xhat.org/posts/windows-createfile-tempfile/</link><pubDate>Mon, 19 Jul 2021 09:36:38 +0800</pubDate><guid>https://blog.xhat.org/posts/windows-createfile-tempfile/</guid><description>在 Windows 上希望创建一个临时文件，该文件在程序退出时自动删除，即使是被强制停止的。这时需要使用 CreateFile 这个函数：
HANDLE CreateFileA( [in] LPCSTR lpFileName, // 指向文件名的指针 [in] DWORD dwDesiredAccess, // 访问模式，写/读 [in] DWORD dwShareMode, // 共享模式 [in, optional] LPSECURITY_ATTRIBUTES lpSecurityAttributes, // 指向安全属性的指针 [in] DWORD dwCreationDisposition, // 如何创建 [in] DWORD dwFlagsAndAttributes, // 文件属性 [in, optional] HANDLE hTemplateFile // 用于复制文件句柄 ); 重点关注dwShareMode和dwFlagsAndAttributes这两个参数。
共享模式dwShareMode有四种选项，分别为
0：禁止其他进程进行删除、读取和写入 FILE_SHARE_DELETE：允许删除 FILE_SHARE_READ：允许读取 FILE_SHARE_WRITE：允许写入 文件属性dwFlagsAndAttributes需要设定两项：
FILE_ATTRIBUTE_TEMPORARY：该文件为临时文件，尽可能使用内存缓存，避免写入磁盘。 FILE_FLAG_DELETE_ON_CLOSE：当所有句柄被关闭时，立刻删除文件。 实验：
h, _ := windows.CreateFile( windows.StringToUTF16Ptr(&amp;#34;tmp&amp;#34;), windows.GENERIC_WRITE, windows.FILE_SHARE_READ, nil, windows.OPEN_ALWAYS, windows.FILE_ATTRIBUTE_TEMPORARY|windows.FILE_FLAG_DELETE_ON_CLOSE, 0, ) var done uint32 windows.</description></item></channel></rss>