<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Golang on xhat's Blog</title><link>https://xhat.org/tags/golang/</link><description>Recent content in Golang on xhat's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 15 Mar 2022 09:28:08 +0800</lastBuildDate><atom:link href="https://xhat.org/tags/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>使用 MQTT 实现 API 接口</title><link>https://xhat.org/posts/mqtt-create-api/</link><pubDate>Tue, 15 Mar 2022 09:28:08 +0800</pubDate><guid>https://xhat.org/posts/mqtt-create-api/</guid><description>MQTT (Message Queuing Telemetry Transport Protocol) 消息队列遥测传输协议，是一种轻量级的发布/订阅模式的消息传输协议，运行在 TCP 协议栈之上，为其提供有序、可靠、双向连接的网络连接保证。
MQTT最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。做为一种低开销、低带宽占用的即时通讯协议，使其在物联网、小型设备、移动应用等方面有较广泛的应用。
最近项目上需要用到 MQTT 采集设备数据，然后项目中的某个应用又需要向外提供接口，项目中的其他应用都需要用到 MQTT，因此想到利用 MQTT 完成多个应用之间的通讯。
API 接口一般是请求/响应模型，MQTT v5 也开始支持请求响应的模式了，具体的流程如下：
请求方在发布消息时包含 响应主题(Response Topic) 属性，比如使用客户端标识符 (Client ID)。 请求方在发布消息时包含 对比数据(Correlation Data) 属性，比如使用当前时间戳。请求可以是异步的，如果同时发送多个请求，那请求方需要一个字段来区分响应消息属于哪个请求。 响应方收到消息后，进行业务处理，处理完成后向该消息的 响应主题 属性指定的主题发布响应消息，同时该响应消息的 对比数据 属性与请求消息的一致。 请求方收到响应消息后，根据 对比数据 属性把消息转发给对应的请求。 实现 本文使用 github.com/eclipse/paho.golang 这个包举例。
服务端 服务端的工作和 Web 框架类似，监听多个 Topic，为每个 Topic 指定处理函数。当一个请求到来时，创建新的协程来单独处理业务。
type Engine struct { Subscriptions map[string]paho.SubscribeOptions router *paho.StandardRouter cm *autopaho.ConnectionManager } func New() *Engine { return &amp;amp;Engine{ router: paho.</description></item><item><title>Golang 程序以 Windows 服务运行</title><link>https://xhat.org/posts/golang-windows-service/</link><pubDate>Fri, 12 Nov 2021 13:15:06 +0800</pubDate><guid>https://xhat.org/posts/golang-windows-service/</guid><description>Windows 服务是运行后台程序的一个很好的选择，可以支持开机自动启动，程序异常退出后自动重启这些实用功能。
Windows 服务程序有一套自己的机制。如果你不想在你的程序添加任何代码的话，有一些工具可以直接把可执行程序作为 Windows 服务运行，比如 winsw。
本文介绍的是在 Go 中制作自己的服务程序，主要使用的是 golang.org/x/sys/windows/svc 这个包。正如文档所说，实现Handler接口即可，当服务启动时，会调用Execute方法。
type demoService struct { } func (service *demoService) Execute(args []string, r &amp;lt;-chan svc.ChangeRequest, changes chan&amp;lt;- svc.Status) (svcSpecificEC bool, exitCode uint32) { changes &amp;lt;- svc.Status{State: svc.StartPending} defer func() { changes &amp;lt;- svc.Status{State: svc.StopPending} log.Println(&amp;#34;Shutting down&amp;#34;) }() // 要执行的主程序代码 go yourMainFunc() changes &amp;lt;- svc.Status{State: svc.Running, Accepts: svc.AcceptStop | svc.</description></item><item><title>Golang 在 Windows 下防止程序多开</title><link>https://xhat.org/posts/golang-gui-singleton/</link><pubDate>Mon, 11 Oct 2021 11:02:41 +0800</pubDate><guid>https://xhat.org/posts/golang-gui-singleton/</guid><description>当用户运行多个程序实例，如果操作的是同一资源，可能会造成数据不一致。所以有一个防止多开的需求，原理上是利用 CreateMutex 这个函数创建互斥对象。
func checkSingleton() (windows.Handle, error) { path, err := os.Executable() if err != nil { return 0, err } hashName := md5.Sum([]byte(path)) name, err := syscall.UTF16PtrFromString(&amp;#34;Local\\&amp;#34; + hex.EncodeToString(hashName[:])) if err != nil { return 0, err } return windows.CreateMutex(nil, false, name) } 检查error，如果是syscall.ERROR_ALREADY_EXISTS，则说明有一个程序已经在运行。
上面创建的互斥对象是局部的(有Local前缀)，多个用户登录还是可以同时多开程序的。如果需要全局限制，则替换为Global前缀。如果你的程序以服务的形式运行，则可能需要设置互斥对象的权限。
func checkSingleton() (windows.Handle, error) { path, err := os.Executable() if err != nil { panic(err) } hashName := md5.</description></item><item><title>Golang 打开 Windows 服务属性窗口</title><link>https://xhat.org/posts/golang-service-property/</link><pubDate>Sun, 01 Aug 2021 11:35:17 +0800</pubDate><guid>https://xhat.org/posts/golang-service-property/</guid><description>本文介绍如何在 Golang 程序里面打开某个 Windows 服务的属性窗口，这里需要用到 COM 接口，详细文档请参考 MMC 2.0 的官方文档。
既然是 COM 的话，程序里也可以使用cmd或者powershell来调用 COM 打开服务窗口。下面介绍直接调用 COM 组件的方法：
使用 github.com/go-ole/go-ole 这个库调用 COM：
import ( &amp;#34;github.com/go-ole/go-ole&amp;#34; &amp;#34;github.com/go-ole/go-ole/oleutil&amp;#34; &amp;#34;time&amp;#34; ) // 服务的显示名称 displayName := &amp;#34;Windows Update&amp;#34; ole.CoInitialize(0) unknown, _ := oleutil.CreateObject(&amp;#34;MMC20.Application&amp;#34;) mmc, _ = unknown.QueryInterface(ole.IID_IDispatch) // 读取服务 oleutil.MustCallMethod(mmc, &amp;#34;Load&amp;#34;, &amp;#34;services.msc&amp;#34;) document := oleutil.MustGetProperty(mmc, &amp;#34;Document&amp;#34;).ToIDispatch() view := oleutil.MustGetProperty(document, &amp;#34;ActiveView&amp;#34;).ToIDispatch() list := oleutil.MustGetProperty(view, &amp;#34;ListItems&amp;#34;).ToIDispatch() count := int(oleutil.MustGetProperty(list, &amp;#34;Count&amp;#34;).Val) // 注意索引从1开始 for i := 1; i &amp;lt;= count; i++ { item := oleutil.</description></item><item><title>Golang 中使用 JWT 进行认证</title><link>https://xhat.org/posts/golang-jwt/</link><pubDate>Mon, 10 May 2021 13:19:47 +0800</pubDate><guid>https://xhat.org/posts/golang-jwt/</guid><description>JSON Web Token (JWT) 是一种目前流行的跨域认证方案，JWT 是基于 JSON 的经过签名的 Token，可以在进行验证的同时附带身份信息，保证传输的信息没有被修改，对于前后端分离项目很有帮助。
JSON Web Token (JWT) 是一个开放标准 (RFC 7519)，它定义了一种紧凑的、自包含的方式，用于作为 JSON 对象在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。
原理 JWT 的认证流程是，用户登录成功后，服务端生成一个 JWT 格式的 Token，发回给用户，这个 Token 包含了用于标记用户的信息，此后用户与服务端通信时，都携带这个 Token，服务端就能靠这个 Token 确定用户的身份。
如上面提到，这个 Token 是有签名的，所以可以保证数据不被篡改，是值得信任的。
JWT 由三部分组成，它们之间用圆点(.)相连。分别为：
Header（头部） Payload（负载） Signature（签名） 最后生成的字符串大概就是这样子的：
xxx.yyy.zzz 下面简单说一下这三个部分。
Header 头部主要用来描述一些元数据。
{ &amp;#34;alg&amp;#34;: &amp;#34;HS256&amp;#34;, &amp;#34;typ&amp;#34;: &amp;#34;JWT&amp;#34; } 主要就包含这两个字段，alg是所使用的签名算法，服务端会使用该算法签名或验证 Token，typ就是类型了，固定为JWT。
最后使用 Base64URL 算法把这个 JSON 对象转换为字符串。
可以看到这部分是没有加密的，所以不要放置敏感信息。
Payload 负载部分用来存放实际传递的数据，也就是关于用户的数据，JWT 官方提供了七个预定义的字段：
{ &amp;#34;iss&amp;#34;: &amp;#34;签发人&amp;#34;, &amp;#34;exp&amp;#34;: &amp;#34;过期时间&amp;#34;, &amp;#34;sub&amp;#34;: &amp;#34;主题&amp;#34;, &amp;#34;aud&amp;#34;: &amp;#34;受众&amp;#34;, &amp;#34;nbf&amp;#34;: &amp;#34;生效时间&amp;#34;, &amp;#34;iat&amp;#34;: &amp;#34;签发时间&amp;#34;, &amp;#34;jti&amp;#34;: &amp;#34;编号&amp;#34; } 除此之外，我们可以自己定义需要的字段：</description></item><item><title>Golang 使用 Casbin 进行权限管理</title><link>https://xhat.org/posts/golang-casbin/</link><pubDate>Thu, 04 Mar 2021 01:18:53 +0800</pubDate><guid>https://xhat.org/posts/golang-casbin/</guid><description>先说需求，设计一个基于角色的权限控制系统，满足以下几个规则：
单独配置某个角色对某个资源的访问权限 一个用户可拥有多个角色 可对角色进行禁用或启用 各个角色之间的权限为并集，且只要有一个角色有权限，该用户就有权限操作 可对一个菜单下的某些重要功能做单独控制，当用户有该菜单的访问权限，没有功能访问权限时，依然能访问该菜单下的非功能接口 Casbin 是一个强大的、高效的开源访问控制框架，其权限管理机制支持多种访问控制模型。
具体支持的模型官网有详细描述，回到本例应该使用的模型是RBAC (基于角色的访问控制)。
Casbin使用配置文件来设置访问控制模式。它有两个配置文件，model.conf和policy.csv。 其中，model.conf存储了访问模型，policy.csv存储了特定的用户权限配置。
模型 Casbin 将访问控制模型抽象为基于PERM(Policy, Effect, Request, Matcher)的一个文件，分别为：
策略 效果 请求 匹配器 基于角色的访问控制需要在此基础上加多一个role_definition进行角色的定义。
请求(request_definition) 该部分用于请求的定义，经典的三元组：访问实体 (Subject)，访问资源 (Object) 和访问方法 (Action)，也可以根据自己的需求进行增加或删除字段。后端常用的控制请求就是uid, /api/res1, GET。
[request_definition] r = sub, obj, act 策略(policy_definition) 该部分定义控制策略的模板，哪个实体对哪个资源有怎样的权限。注意：这里的sub, obj不一定需要与请求里面的值一致，具体怎样匹配是匹配器定义的。例如这里的一条策略可以是alice, res1, allow。
[policy_definition] p = sub, obj, eft 角色定义(role_definition) 该部分定义了角色系统，用户可以具有角色及其继承关系, 资源也可以具有角色及其继承关系。 这两个 RBAC 系统不会互相干扰。这里我使用了三个角色系统：g是用户和角色的从属关系；g2是资源的从属关系；g3是角色的开关。
[role_definition] g = _, _ g2 = _, _, _ g3 = _, _ 举个例子，g可以是user_1, 1，表示uid是 1 的用户拥有角色 1。g2可以理解为将多个接口组成一个资源组，角色拥有该资源组的权限则有这些接口的访问权限。</description></item></channel></rss>