<!doctype html><html lang=zh-CN id=page><head><meta charset=utf-8><title>获取 TCP 发送缓冲区信息 - X̂ Blog</title><meta name=viewport content="width=device-width,initial-scale=1"><link href=/css/font.css type=text/css rel=stylesheet><link href=/css/main.css type=text/css rel=stylesheet><link href=/css/github-markdown-light.css type=text/css rel=stylesheet><link rel=icon href=/favicon.svg></head><body><header><a href=/ id=logo><svg xmlns="http://www.w3.org/2000/svg" width="38.82" height="52.68" viewBox="0 -765 572 776" xmlns:xlink="http://www.w3.org/1999/xlink" style><defs><path id="MJX-9-TEX-I-78" d="M52 289q7 42 54 97t116 56q35 0 64-18t43-45q42 63 101 63 37 0 64-22t28-59q0-29-14-47t-27-22-23-4q-19 0-31 11t-12 29q0 46 50 63-11 13-40 13-13 0-19-2-38-16-56-66-60-221-60-258 0-28 16-40t35-12q37 0 73 33t49 81q3 10 6 11t16 2h4q15 0 15-8 0-1-2-11-16-57-62-101T333-11q-70 0-106 63-41-62-94-62h-6Q78-10 57 16T35 71q0 32 19 52t45 20q43 0 43-42 0-20-12-35T107 46 94 41l-3-1q0-1 6-4t16-7 19-3q36 0 62 45 9 16 23 68t28 108 16 66q5 27 5 39 0 28-15 40t-34 12q-40 0-75-32T93 290q-2-9-5-10t-16-2H58q-6 6-6 11z"/><path id="MJX-9-TEX-N-5E" d="M112 560 249 694l8-8Q387 562 387 560l-26-29q-2 1-58 50l-53 46-55-47q-13-11-26-23t-21-19l-8-6q-2-2-15 14l-13 14z"/></defs><g stroke="currentcolor" fill="currentcolor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="TeXAtom"><g data-mml-node="mover"><g data-mml-node="mi"><use xlink:href="#MJX-9-TEX-I-78"/></g><g data-mml-node="mo" transform="translate(63.8, -29)"><use xlink:href="#MJX-9-TEX-N-5E"/></g></g></g></g></g></svg><b>xhat</b></a><nav><ul><li><a href=/ class=active>文章</a></li><li><a href=/tags/>标签</a></li><li><a href=/archives/>归档</a></li><li><a href=/about/>关于</a></li></ul></nav></header><section class=main><article class=content><h2 class=title>获取 TCP 发送缓冲区信息</h2><div class=remark><time datetime="2023-05-04 16:37:47 +0800 +0800">2023-05-04</time></div><div class=tags><a href=/tags/%E7%BD%91%E7%BB%9C/>网络</a>
<a href=/tags/tcp/>TCP</a></div><div class=markdown-body><p>在大多数的网络编程情况下，是不需要特意关心 TCP 的缓冲区信息的。但在一些工业应用场景，如 RS485 转网口的数据采集，半双工的 485 不能同时进行读和写，这就要求 TCP 确认发送完一个指令后，才能发第二条。因为是总线网络，同时发送多条指令，对端回复数据将出现错乱。</p><p>当应用程序往套接字写入数据时，实际上只是写入了内核的发送缓冲区，接收方什么时候能收到报文是个未知数。</p><p>因此在某些需要同步状态的地方，发送方最好能确认对方收到报文后再做下一步动作。</p><h2 id=linux>Linux</h2><p>Linux 提供了 <code>ioctl(fd, SIOCOUTQ, &amp;count)</code> 方法来查询一个套接字是否有未发送完成的数据。</p><blockquote><p>SIOCOUTQ
Returns the amount of unsent data in the socket send queue. The socket must not be in LISTEN state, otherwise an error (EINVAL) is returned. SIOCOUTQ is defined in &lt;linux/sockios.h>. Alternatively, you can use the synonymous TIOCOUTQ, defined in &lt;sys/ioctl.h>.</p></blockquote><p>发送方可以使用这个方法来判断对端是否收到报文。以 Go 为例：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000;font-weight:700>import</span> (
</span></span><span style=display:flex><span>    <span style=color:#d14>&#34;net&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#d14>&#34;golang.org/x/sys/unix&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#d14>&#34;unsafe&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>getSendQueueLength</span>(conn <span style=color:#000;font-weight:700>*</span>net.TCPConn) (qLen <span style=color:#458;font-weight:700>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>if</span> r, err <span style=color:#000;font-weight:700>:=</span> conn.<span style=color:#900;font-weight:700>SyscallConn</span>(); err <span style=color:#000;font-weight:700>==</span> <span style=color:#000;font-weight:700>nil</span> {
</span></span><span style=display:flex><span>		r.<span style=color:#900;font-weight:700>Control</span>(<span style=color:#000;font-weight:700>func</span>(fd <span style=color:#458;font-weight:700>uintptr</span>) {
</span></span><span style=display:flex><span>			unix.<span style=color:#900;font-weight:700>Syscall</span>(unix.SYS_IOCTL, fd, unix.SIOCOUTQ, <span style=color:#0086b3>uintptr</span>(unsafe.<span style=color:#900;font-weight:700>Pointer</span>(<span style=color:#000;font-weight:700>&amp;</span>qLen)))
</span></span><span style=display:flex><span>		})
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=windows>Windows</h2><p>需要用到以下两个 API 函数，这两个函数都有对应的 IPv4 和 IPv6 版本，可按需调用，本文以 IPv4 为例。</p><ol><li><strong>启用 TCP 连接的扩展统计信息</strong></li></ol><blockquote><p>The <a href=https://learn.microsoft.com/zh-cn/windows/win32/api/iphlpapi/nf-iphlpapi-setpertcpconnectionestats><code>SetPerTcpConnectionEStats</code></a> function sets a value in the read/write information for an IPv4 TCP connection. This function is used to enable or disable extended statistics for an IPv4 TCP connection.</p></blockquote><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>IPHLPAPI_DLL_LINKAGE ULONG <span style=color:#900;font-weight:700>SetPerTcpConnectionEStats</span>(
</span></span><span style=display:flex><span>  PMIB_TCPROW     Row,
</span></span><span style=display:flex><span>  TCP_ESTATS_TYPE EstatsType,
</span></span><span style=display:flex><span>  PUCHAR          Rw,
</span></span><span style=display:flex><span>  ULONG           RwVersion,
</span></span><span style=display:flex><span>  ULONG           RwSize,
</span></span><span style=display:flex><span>  ULONG           Offset
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>其中 <code>Row</code> 是描述套接字的四元组信息，<code>EstatsType</code> 是统计信息类型，像本文需要的是发送缓冲区的信息，类型就是 <code>TcpConnectionEstatsSendBuff</code>。</p><p>注意此函数需要管理员权限。</p><ol start=2><li><strong>获取 TCP 连接的扩展统计信息</strong></li></ol><blockquote><p><a href=https://learn.microsoft.com/zh-cn/windows/win32/api/iphlpapi/nf-iphlpapi-getpertcpconnectionestats><code>GetPerTcpConnectionEStats</code></a> 函数检索 IPv4 TCP 连接的扩展统计信息。</p></blockquote><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>IPHLPAPI_DLL_LINKAGE ULONG <span style=color:#900;font-weight:700>GetPerTcpConnectionEStats</span>(
</span></span><span style=display:flex><span>        PMIB_TCPROW     Row,
</span></span><span style=display:flex><span>        TCP_ESTATS_TYPE EstatsType,
</span></span><span style=display:flex><span>  [out] PUCHAR          Rw,
</span></span><span style=display:flex><span>        ULONG           RwVersion,
</span></span><span style=display:flex><span>        ULONG           RwSize,
</span></span><span style=display:flex><span>  [out] PUCHAR          Ros,
</span></span><span style=display:flex><span>        ULONG           RosVersion,
</span></span><span style=display:flex><span>        ULONG           RosSize,
</span></span><span style=display:flex><span>  [out] PUCHAR          Rod,
</span></span><span style=display:flex><span>        ULONG           RodVersion,
</span></span><span style=display:flex><span>        ULONG           RodSize
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>使用 <code>Rod</code> 参数接收发送缓冲区信息。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#000;font-weight:700>typedef</span> <span style=color:#000;font-weight:700>struct</span> _TCP_ESTATS_SEND_BUFF_ROD_v0 {
</span></span><span style=display:flex><span>  SIZE_T CurRetxQueue; <span style=color:#998;font-style:italic>// 占用重新传输队列的数据的当前字节数
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>  SIZE_T MaxRetxQueue; <span style=color:#998;font-style:italic>// 占用重新传输队列的数据的最大字节数
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>  SIZE_T CurAppWQueue; <span style=color:#998;font-style:italic>// TCP 缓冲的应用程序数据的当前字节数
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>  SIZE_T MaxAppWQueue; <span style=color:#998;font-style:italic>// TCP 缓冲的应用程序数据的最大字节数
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>} TCP_ESTATS_SEND_BUFF_ROD_v0, <span style=color:#000;font-weight:700>*</span>PTCP_ESTATS_SEND_BUFF_ROD_v0;
</span></span></code></pre></div><p>Windows 把缓冲区的信息分成两部分数据，一个是重传，另一个是待发送。因此实际发送队列的长度是 <code>CurRetxQueue + CurAppWQueue</code>。</p><h2 id=实例>实例</h2><p>Linux 上的例子上面已有介绍。下面主要说说 Windows 下的实现（IPv4 + IPv6）：</p><ol><li>导入函数</li></ol><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000;font-weight:700>var</span> (
</span></span><span style=display:flex><span>	libIpHlpApi                = syscall.<span style=color:#900;font-weight:700>NewLazyDLL</span>(<span style=color:#d14>&#34;iphlpapi.dll&#34;</span>)
</span></span><span style=display:flex><span>	getPerTcpConnectionEStats  = libIpHlpApi.<span style=color:#900;font-weight:700>NewProc</span>(<span style=color:#d14>&#34;GetPerTcpConnectionEStats&#34;</span>)
</span></span><span style=display:flex><span>	getPerTcp6ConnectionEStats = libIpHlpApi.<span style=color:#900;font-weight:700>NewProc</span>(<span style=color:#d14>&#34;GetPerTcp6ConnectionEStats&#34;</span>)
</span></span><span style=display:flex><span>	setPerTcpConnectionEStats  = libIpHlpApi.<span style=color:#900;font-weight:700>NewProc</span>(<span style=color:#d14>&#34;SetPerTcpConnectionEStats&#34;</span>)
</span></span><span style=display:flex><span>	setPerTcp6ConnectionEStats = libIpHlpApi.<span style=color:#900;font-weight:700>NewProc</span>(<span style=color:#d14>&#34;SetPerTcp6ConnectionEStats&#34;</span>)
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><ol start=2><li>数据结构定义</li></ol><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// 客户端
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>type</span> Client <span style=color:#000;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>    sync.Once
</span></span><span style=display:flex><span>    <span style=color:#998;font-style:italic>// 记录连接的四元组信息
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	tuple [<span style=color:#099>1</span> <span style=color:#000;font-weight:700>&lt;&lt;</span> <span style=color:#099>6</span>]<span style=color:#458;font-weight:700>byte</span>
</span></span><span style=display:flex><span>    conn <span style=color:#000;font-weight:700>*</span>net.TCPConn
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// TCPv4 连接
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>type</span> mibTcpRow <span style=color:#000;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>	state      <span style=color:#458;font-weight:700>uint32</span>
</span></span><span style=display:flex><span>	localAddr  <span style=color:#458;font-weight:700>uint32</span>
</span></span><span style=display:flex><span>	localPort  <span style=color:#458;font-weight:700>uint32</span>
</span></span><span style=display:flex><span>	remoteAddr <span style=color:#458;font-weight:700>uint32</span>
</span></span><span style=display:flex><span>	remotePort <span style=color:#458;font-weight:700>uint32</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// TCPv6 连接
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>type</span> mibTcp6Row <span style=color:#000;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>	state         <span style=color:#458;font-weight:700>uint32</span>
</span></span><span style=display:flex><span>	localAddr     [<span style=color:#099>16</span>]<span style=color:#458;font-weight:700>byte</span>
</span></span><span style=display:flex><span>	localScopeId  <span style=color:#458;font-weight:700>uint32</span>
</span></span><span style=display:flex><span>	localPort     <span style=color:#458;font-weight:700>uint32</span>
</span></span><span style=display:flex><span>	remoteAddr    [<span style=color:#099>16</span>]<span style=color:#458;font-weight:700>byte</span>
</span></span><span style=display:flex><span>	remoteScopeId <span style=color:#458;font-weight:700>uint32</span>
</span></span><span style=display:flex><span>	remotePort    <span style=color:#458;font-weight:700>uint32</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// TCP 发送队列信息
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>type</span> tcpESTATSSendBuffROD <span style=color:#000;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>	curRetxQueue <span style=color:#458;font-weight:700>uint</span> <span style=color:#998;font-style:italic>// 占用重新传输队列的数据的当前字节数
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	maxRetxQueue <span style=color:#458;font-weight:700>uint</span> <span style=color:#998;font-style:italic>// 占用重新传输队列的数据的最大字节数
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	curAppWQueue <span style=color:#458;font-weight:700>uint</span> <span style=color:#998;font-style:italic>// TCP 缓冲的应用程序数据的当前字节数
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	maxAppWQueue <span style=color:#458;font-weight:700>uint</span> <span style=color:#998;font-style:italic>// TCP 缓冲的应用程序数据的最大字节数
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>}
</span></span></code></pre></div><ol start=3><li>启用 TCP 连接的扩展统计信息</li></ol><p>此函数一个连接只需要执行一次。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (c <span style=color:#000;font-weight:700>*</span>Client) <span style=color:#900;font-weight:700>setupTcp</span>() {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>var</span> lp, rp <span style=color:#458;font-weight:700>uint32</span>
</span></span><span style=display:flex><span>	la <span style=color:#000;font-weight:700>:=</span> netip.<span style=color:#900;font-weight:700>MustParseAddrPort</span>(c.conn.<span style=color:#900;font-weight:700>LocalAddr</span>().<span style=color:#900;font-weight:700>String</span>())
</span></span><span style=display:flex><span>	ra <span style=color:#000;font-weight:700>:=</span> netip.<span style=color:#900;font-weight:700>MustParseAddrPort</span>(c.conn.<span style=color:#900;font-weight:700>RemoteAddr</span>().<span style=color:#900;font-weight:700>String</span>())
</span></span><span style=display:flex><span>	lp = <span style=color:#0086b3>uint32</span>(la.<span style=color:#900;font-weight:700>Port</span>()<span style=color:#000;font-weight:700>&gt;&gt;</span><span style=color:#099>8</span> | la.<span style=color:#900;font-weight:700>Port</span>()<span style=color:#000;font-weight:700>&lt;&lt;</span><span style=color:#099>8</span>)
</span></span><span style=display:flex><span>	rp = <span style=color:#0086b3>uint32</span>(ra.<span style=color:#900;font-weight:700>Port</span>()<span style=color:#000;font-weight:700>&gt;&gt;</span><span style=color:#099>8</span> | ra.<span style=color:#900;font-weight:700>Port</span>()<span style=color:#000;font-weight:700>&lt;&lt;</span><span style=color:#099>8</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>var</span> rw = <span style=color:#000;font-weight:700>true</span>
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>var</span> proc <span style=color:#000;font-weight:700>*</span>syscall.LazyProc
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>if</span> la.<span style=color:#900;font-weight:700>Addr</span>().<span style=color:#900;font-weight:700>Is4</span>() {
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>*</span>(<span style=color:#000;font-weight:700>**</span>syscall.LazyProc)(unsafe.<span style=color:#900;font-weight:700>Pointer</span>(<span style=color:#000;font-weight:700>&amp;</span>c.tuple)) = getPerTcpConnectionEStats
</span></span><span style=display:flex><span>		proc = setPerTcpConnectionEStats
</span></span><span style=display:flex><span>		<span style=color:#0086b3>copy</span>(c.tuple[unsafe.<span style=color:#900;font-weight:700>Sizeof</span>(<span style=color:#0086b3>uintptr</span>(<span style=color:#099>0</span>)):], unsafe.<span style=color:#900;font-weight:700>Slice</span>((<span style=color:#000;font-weight:700>*</span><span style=color:#458;font-weight:700>byte</span>)(unsafe.<span style=color:#900;font-weight:700>Pointer</span>(<span style=color:#000;font-weight:700>&amp;</span>mibTcpRow{
</span></span><span style=display:flex><span>			localAddr:  binary.LittleEndian.<span style=color:#900;font-weight:700>Uint32</span>(la.<span style=color:#900;font-weight:700>Addr</span>().<span style=color:#900;font-weight:700>AsSlice</span>()),
</span></span><span style=display:flex><span>			localPort:  lp,
</span></span><span style=display:flex><span>			remoteAddr: binary.LittleEndian.<span style=color:#900;font-weight:700>Uint32</span>(ra.<span style=color:#900;font-weight:700>Addr</span>().<span style=color:#900;font-weight:700>AsSlice</span>()),
</span></span><span style=display:flex><span>			remotePort: rp,
</span></span><span style=display:flex><span>		})), unsafe.<span style=color:#900;font-weight:700>Sizeof</span>(mibTcpRow{})))
</span></span><span style=display:flex><span>	} <span style=color:#000;font-weight:700>else</span> {
</span></span><span style=display:flex><span>		row <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>&amp;</span>mibTcp6Row{
</span></span><span style=display:flex><span>			localAddr:  la.<span style=color:#900;font-weight:700>Addr</span>().<span style=color:#900;font-weight:700>As16</span>(),
</span></span><span style=display:flex><span>			localPort:  lp,
</span></span><span style=display:flex><span>			remoteAddr: ra.<span style=color:#900;font-weight:700>Addr</span>().<span style=color:#900;font-weight:700>As16</span>(),
</span></span><span style=display:flex><span>			remotePort: rp,
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>if</span> lif, err <span style=color:#000;font-weight:700>:=</span> net.<span style=color:#900;font-weight:700>InterfaceByName</span>(la.<span style=color:#900;font-weight:700>Addr</span>().<span style=color:#900;font-weight:700>Zone</span>()); err <span style=color:#000;font-weight:700>==</span> <span style=color:#000;font-weight:700>nil</span> {
</span></span><span style=display:flex><span>			row.localScopeId = <span style=color:#0086b3>uint32</span>(lif.Index)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>if</span> rif, err <span style=color:#000;font-weight:700>:=</span> net.<span style=color:#900;font-weight:700>InterfaceByName</span>(ra.<span style=color:#900;font-weight:700>Addr</span>().<span style=color:#900;font-weight:700>Zone</span>()); err <span style=color:#000;font-weight:700>==</span> <span style=color:#000;font-weight:700>nil</span> {
</span></span><span style=display:flex><span>			row.remoteScopeId = <span style=color:#0086b3>uint32</span>(rif.Index)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>*</span>(<span style=color:#000;font-weight:700>**</span>syscall.LazyProc)(unsafe.<span style=color:#900;font-weight:700>Pointer</span>(<span style=color:#000;font-weight:700>&amp;</span>c.tuple)) = getPerTcp6ConnectionEStats
</span></span><span style=display:flex><span>		proc = setPerTcp6ConnectionEStats
</span></span><span style=display:flex><span>		<span style=color:#0086b3>copy</span>(c.tuple[unsafe.<span style=color:#900;font-weight:700>Sizeof</span>(<span style=color:#0086b3>uintptr</span>(<span style=color:#099>0</span>)):], unsafe.<span style=color:#900;font-weight:700>Slice</span>((<span style=color:#000;font-weight:700>*</span><span style=color:#458;font-weight:700>byte</span>)(unsafe.<span style=color:#900;font-weight:700>Pointer</span>(row)), unsafe.<span style=color:#900;font-weight:700>Sizeof</span>(mibTcp6Row{})))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// 启用 TCP 连接的扩展统计信息
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	r, _, _ <span style=color:#000;font-weight:700>:=</span> proc.<span style=color:#900;font-weight:700>Call</span>(<span style=color:#0086b3>uintptr</span>(unsafe.<span style=color:#900;font-weight:700>Pointer</span>(<span style=color:#000;font-weight:700>&amp;</span>c.tuple[unsafe.<span style=color:#900;font-weight:700>Sizeof</span>(<span style=color:#0086b3>uintptr</span>(<span style=color:#099>0</span>))])), <span style=color:#099>4</span>, <span style=color:#0086b3>uintptr</span>(unsafe.<span style=color:#900;font-weight:700>Pointer</span>(<span style=color:#000;font-weight:700>&amp;</span>rw)), <span style=color:#099>0</span>, unsafe.<span style=color:#900;font-weight:700>Sizeof</span>(rw), <span style=color:#099>0</span>)
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>if</span> r <span style=color:#000;font-weight:700>!=</span> windows.NO_ERROR {
</span></span><span style=display:flex><span>		fmt.<span style=color:#900;font-weight:700>Println</span>(<span style=color:#d14>&#34;setPerTcpConnectionEStats error:&#34;</span>, windows.<span style=color:#900;font-weight:700>Errno</span>(r))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=4><li>获取发送队列长度</li></ol><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (c <span style=color:#000;font-weight:700>*</span>Client) <span style=color:#900;font-weight:700>getSendQueueLength</span>() (qLen <span style=color:#458;font-weight:700>int</span>) {
</span></span><span style=display:flex><span>	c.<span style=color:#900;font-weight:700>Do</span>(c.setupTcp)
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>var</span> buf tcpESTATSSendBuffROD
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>var</span> rw = <span style=color:#000;font-weight:700>true</span>
</span></span><span style=display:flex><span>	r, _, _ <span style=color:#000;font-weight:700>:=</span> (<span style=color:#000;font-weight:700>*</span>(<span style=color:#000;font-weight:700>**</span>syscall.LazyProc)(unsafe.<span style=color:#900;font-weight:700>Pointer</span>(<span style=color:#000;font-weight:700>&amp;</span>c.tuple))).<span style=color:#900;font-weight:700>Call</span>(<span style=color:#0086b3>uintptr</span>(unsafe.<span style=color:#900;font-weight:700>Pointer</span>(<span style=color:#000;font-weight:700>&amp;</span>c.tuple[unsafe.<span style=color:#900;font-weight:700>Sizeof</span>(<span style=color:#0086b3>uintptr</span>(<span style=color:#099>0</span>))])), <span style=color:#099>4</span>,
</span></span><span style=display:flex><span>		<span style=color:#0086b3>uintptr</span>(unsafe.<span style=color:#900;font-weight:700>Pointer</span>(<span style=color:#000;font-weight:700>&amp;</span>rw)), <span style=color:#099>0</span>, unsafe.<span style=color:#900;font-weight:700>Sizeof</span>(rw),
</span></span><span style=display:flex><span>		<span style=color:#099>0</span>, <span style=color:#099>0</span>, <span style=color:#099>0</span>,
</span></span><span style=display:flex><span>		<span style=color:#0086b3>uintptr</span>(unsafe.<span style=color:#900;font-weight:700>Pointer</span>(<span style=color:#000;font-weight:700>&amp;</span>buf)), <span style=color:#099>0</span>, unsafe.<span style=color:#900;font-weight:700>Sizeof</span>(buf))
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>if</span> r <span style=color:#000;font-weight:700>!=</span> windows.NO_ERROR <span style=color:#000;font-weight:700>||</span> !rw {
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>return</span> <span style=color:#099>0</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span> <span style=color:#0086b3>int</span>(buf.curRetxQueue <span style=color:#000;font-weight:700>+</span> buf.curAppWQueue)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><link href=https://cdn.bootcdn.net/ajax/libs/KaTeX/0.12.0/katex.min.css rel=stylesheet><script src=https://cdn.bootcdn.net/ajax/libs/KaTeX/0.12.0/katex.min.js></script>
<script src=https://cdn.bootcdn.net/ajax/libs/KaTeX/0.12.0/contrib/auto-render.min.js onload='renderMathInElement(document.querySelector(`.content`),{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})'></script></article></section><section class=tail><div class=content id=post-nav><a title="为 NGINX 签发 HTTPS 证书" rel=prev href=/posts/issue-nginx-cert/><span>前篇</span>为 NGINX 签发 HTTPS 证书</a>
<a title="OpenSSL 生成自签名证书" rel=next href=/posts/openssl-self-signed/><span>后篇</span>OpenSSL 生成自签名证书</a></div><div class=content id=post-comment><script src=https://giscus.app/client.js data-repo=koho/blog data-repo-id="MDEwOlJlcG9zaXRvcnkzMjM1MDUxMDk=" data-category=Announcements data-category-id=DIC_kwDOE0hL1c4COeTz data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=light data-lang=zh-CN crossorigin=anonymous async></script></div><div class=content id=post-related><h3 class=title>延伸阅读</h3><div class=grid><div class=card><a href=/posts/linux-wireguard/ rel=bookmark><div class=banner style=background-image:url(/images/wireguard-ubuntu.jpg)></div><h4>Linux 部署 WireGuard</h4><p>2021-09-03</p><div class=tags><span>Linux</span>
<span>网络</span></div></a></div><div class=card><a href=/posts/python-arpspoof/ rel=bookmark><div class=banner style=background-image:url(/images/cyber-security.jpg)></div><h4>Python 进行 ARP 欺骗</h4><p>2021-06-09</p><div class=tags><span>Python</span>
<span>网络</span></div></a></div></div></div></section><footer><span>Powered by <a href=https://gohugo.io>Hugo</a></span><br><span>© 2022 xhat</span></footer></body></html>