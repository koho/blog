<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>2022 on xhat's Blog</title><link>https://xhat.org/archives/2022/</link><description>Recent content in 2022 on xhat's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 05 Dec 2022 00:19:04 +0800</lastBuildDate><atom:link href="https://xhat.org/archives/2022/index.xml" rel="self" type="application/rss+xml"/><item><title>为 NGINX 签发 HTTPS 证书</title><link>https://xhat.org/posts/issue-nginx-cert/</link><pubDate>Mon, 05 Dec 2022 00:19:04 +0800</pubDate><guid>https://xhat.org/posts/issue-nginx-cert/</guid><description>目前有很多 CA 可以免费签发 3 个月的 HTTPS 证书，如 Let&amp;rsquo;s Encrypt，ZeroSSL 等。推荐使用 acme.sh 脚本来管理证书，可以简化签发流程，证书到期可以自动续签。
安装 curl https://get.acme.sh | sh Let&amp;rsquo;s Encrypt 域名验证方式有很多种，以阿里云的 DNS 认证为例：
export Ali_Key=&amp;#34;&amp;#34; export Ali_Secret=&amp;#34;&amp;#34; 签发指定域名证书：
/root/.acme.sh/acme.sh --server letsencrypt --issue --dns dns_ali -d a.example.com 成功后会输出证书保存目录，而且脚本在证书到期前会自动续签证书。
安装证书到指定目录：
/root/.acme.sh/acme.sh --install-cert -d a.example.com --fullchain-file /etc/a.example.com.cer --key-file /etc/a.example.com.key --reloadcmd &amp;#34;systemctl restart nginx&amp;#34; 当证书续签后，上面的安装命令也会再次执行。
Nginx 配置 server { listen 443 ssl http2; listen [::]:443 ssl http2; ssl_certificate /etc/a.example.com.cer; ssl_certificate_key /etc/a.example.com.key; ssl_protocols TLSv1.3 TLSv1.2; server_name a.</description></item><item><title>ECC 椭圆曲线</title><link>https://xhat.org/posts/elliptic-curve/</link><pubDate>Mon, 26 Sep 2022 09:18:01 +0800</pubDate><guid>https://xhat.org/posts/elliptic-curve/</guid><description>椭圆曲线密码学（Elliptic Curve Cryptography, ECC）是一种基于椭圆曲线数学的非对称式密码学算法。
ECC 的主要优势是它相比 RSA 加密算法使用较小的密钥长度并提供相当等级的安全性。
如今，在现代计算机网络技术中，比如 TLS、PGP 和 SSH，都有用到椭圆曲线加密算法。更不要说去中心化系统，如比特币和其它加密电子货币了。
椭圆曲线 椭圆曲线是由这个方程描述的平面曲线：
$$ y^2 = x^3 + ax + b $$
其中 $a$, $b$ 都是实数。上述方程就是所谓的魏尔斯特拉斯一般形式。
为排除退化成奇异曲线的情况，还需要满足 $4a^3 + 27b^2 \ne 0$。
随着 $a$ 和 $b$ 取值的变化，椭圆曲线可能在平面上会呈现不同的性状。不论是直观还是证明，我们都可以发现椭圆曲线是关于 $x$ 轴对称的。
群 在数学中，群（Group）是由一个集合以及一个二元运算符所组成的代数结构，且符合以下四个性质：
封闭性：对于所有 $G$ 中的 $a$, $b$，运算 $a \cdot b$ 的结果也在 $G$ 中。
结合律：对于所有 $G$ 中的 $a$, $b$, $c$，等式 $(a \cdot b) \cdot c = a \cdot (b \cdot c)$ 成立。</description></item><item><title>理解 RNN</title><link>https://xhat.org/posts/understanding-rnn/</link><pubDate>Thu, 21 Apr 2022 11:38:04 +0800</pubDate><guid>https://xhat.org/posts/understanding-rnn/</guid><description>循环神经网络 (Recurrent Neural Network, RNN) 是一种用于处理时间序列数据的神经网络结构。包括文字、语音、视频等对象。这些数据有两个主要特点：
数据无固定长度 数据是有时序的，相邻数据之间存在相关性，非相互独立 考虑这样一个问题，如果要预测句子下一个单词是什么，一般需要用到当前单词以及前面的单词，因为句子中前后单词并不是独立的。比如，当前单词是“很”，前一个单词是“天空”，那么下一个单词很大概率是“蓝”。循环神经网络就像人一样拥有记忆的能力，它的输出依赖于当前的输入和记忆，刻画出一个序列当前的输出与之前信息的关系。
循环神经网络适用于许多序列问题中，例如文本处理、语音识别以及机器翻译等。
基本结构 如果把上面有 W 的那个带箭头的圈去掉，它就变成了普通的全连接神经网络。图中每个圆圈可以看作是一个单元，而且每个单元做的事情也是一样的，因此可以折叠呈左半图的样子。用一句话解释 RNN，就是一个单元结构重复使用。
简单理清一下各符号的定义：
$x_t$ 表示 t 时刻的输入 $y_t$ 表示 t 时刻的输出 $s_t$ 表示 t 时刻的记忆，即隐藏层的输出 U 是输入层到隐藏层之间的权重矩阵 W 是记忆单元到隐藏层之间的权重矩阵 V 是隐藏层到输出层之间的权重矩阵 U, W, V 都是权重矩阵，在不同时刻 t 之间是共享权重的 从右半图可以看到，RNN 每个时刻隐藏层输出都会传递给下一时刻，因此每个时刻的网络都会保留一定的来自之前时刻的历史信息，并结合当前时刻的网络状态一并再传给下一时刻。
比如在文本预测中，文本序列为 &amp;ldquo;machine&amp;rdquo;，则输入序列和标签序列分别为 &amp;ldquo;machin&amp;rdquo; 和 &amp;ldquo;achine&amp;rdquo;，网络的概览图如下： 前向计算 在一个循环神经网络中，假设隐藏层只有一层。在 t 时刻神经网络接收到一个输入 $x_t$，则隐藏层的输出 $s_t$ 为： $$ s_t = \tanh(Ux_t + Ws_{t-1} + b_s) $$
在神经网络刚开始训练时，记忆单元中没有上一时刻的网络状态，这时候 $s_{t-1}$ 就是一个初始值。
在得到隐藏层的输出后，神经网络的输出 $y_t$ 为： $$ y_t = \mathrm{softmax}(Vs_t + b_y) $$</description></item><item><title>使用 MQTT 实现 API 接口</title><link>https://xhat.org/posts/mqtt-create-api/</link><pubDate>Tue, 15 Mar 2022 09:28:08 +0800</pubDate><guid>https://xhat.org/posts/mqtt-create-api/</guid><description>MQTT (Message Queuing Telemetry Transport Protocol) 消息队列遥测传输协议，是一种轻量级的发布/订阅模式的消息传输协议，运行在 TCP 协议栈之上，为其提供有序、可靠、双向连接的网络连接保证。
MQTT最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。做为一种低开销、低带宽占用的即时通讯协议，使其在物联网、小型设备、移动应用等方面有较广泛的应用。
最近项目上需要用到 MQTT 采集设备数据，然后项目中的某个应用又需要向外提供接口，项目中的其他应用都需要用到 MQTT，因此想到利用 MQTT 完成多个应用之间的通讯。
API 接口一般是请求/响应模型，MQTT v5 也开始支持请求响应的模式了，具体的流程如下：
请求方在发布消息时包含 响应主题(Response Topic) 属性，比如使用客户端标识符 (Client ID)。 请求方在发布消息时包含 对比数据(Correlation Data) 属性，比如使用当前时间戳。请求可以是异步的，如果同时发送多个请求，那请求方需要一个字段来区分响应消息属于哪个请求。 响应方收到消息后，进行业务处理，处理完成后向该消息的 响应主题 属性指定的主题发布响应消息，同时该响应消息的 对比数据 属性与请求消息的一致。 请求方收到响应消息后，根据 对比数据 属性把消息转发给对应的请求。 实现 本文使用 github.com/eclipse/paho.golang 这个包举例。
服务端 服务端的工作和 Web 框架类似，监听多个 Topic，为每个 Topic 指定处理函数。当一个请求到来时，创建新的协程来单独处理业务。
type Engine struct { Subscriptions map[string]paho.SubscribeOptions router *paho.StandardRouter cm *autopaho.ConnectionManager } func New() *Engine { return &amp;amp;Engine{ router: paho.NewStandardRouter(), Subscriptions: make(map[string]paho.SubscribeOptions), } } func (engine *Engine) Route(topic string, handler func(string, []byte) []byte) { engine.</description></item><item><title>给 exe 添加文件信息</title><link>https://xhat.org/posts/file-info-exe/</link><pubDate>Tue, 08 Feb 2022 15:36:31 +0800</pubDate><guid>https://xhat.org/posts/file-info-exe/</guid><description>创建清单文件 文件名为manifest.xml。如果不需要管理器权限，就把trustInfo删掉。
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34; standalone=&amp;#34;yes&amp;#34;?&amp;gt; &amp;lt;assembly xmlns=&amp;#34;urn:schemas-microsoft-com:asm.v1&amp;#34; manifestVersion=&amp;#34;1.0&amp;#34;&amp;gt; &amp;lt;assemblyIdentity version=&amp;#34;1.0.0.0&amp;#34; processorArchitecture=&amp;#34;*&amp;#34; name=&amp;#34;app&amp;#34; type=&amp;#34;win32&amp;#34;/&amp;gt; &amp;lt;trustInfo xmlns=&amp;#34;urn:schemas-microsoft-com:asm.v2&amp;#34;&amp;gt; &amp;lt;security&amp;gt; &amp;lt;requestedPrivileges xmlns=&amp;#34;urn:schemas-microsoft-com:asm.v3&amp;#34;&amp;gt; &amp;lt;requestedExecutionLevel level=&amp;#34;requireAdministrator&amp;#34; uiAccess=&amp;#34;false&amp;#34; /&amp;gt; &amp;lt;/requestedPrivileges&amp;gt; &amp;lt;/security&amp;gt; &amp;lt;/trustInfo&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;dependentAssembly&amp;gt; &amp;lt;assemblyIdentity type=&amp;#34;win32&amp;#34; name=&amp;#34;Microsoft.Windows.Common-Controls&amp;#34; version=&amp;#34;6.0.0.0&amp;#34; processorArchitecture=&amp;#34;*&amp;#34; publicKeyToken=&amp;#34;6595b64144ccf1df&amp;#34; language=&amp;#34;*&amp;#34;/&amp;gt; &amp;lt;/dependentAssembly&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;application xmlns=&amp;#34;urn:schemas-microsoft-com:asm.v3&amp;#34;&amp;gt; &amp;lt;windowsSettings&amp;gt; &amp;lt;dpiAwareness xmlns=&amp;#34;http://schemas.microsoft.com/SMI/2016/WindowsSettings&amp;#34;&amp;gt;PerMonitorV2, PerMonitor&amp;lt;/dpiAwareness&amp;gt; &amp;lt;dpiAware xmlns=&amp;#34;http://schemas.microsoft.com/SMI/2005/WindowsSettings&amp;#34;&amp;gt;True&amp;lt;/dpiAware&amp;gt; &amp;lt;/windowsSettings&amp;gt; &amp;lt;/application&amp;gt; &amp;lt;/assembly&amp;gt; 创建资源文件 文件名为resources.rc，如果没有清单文件，可将对应的行删掉，图标文件类似。
#include &amp;lt;windows.h&amp;gt; #pragma code_page(65001) // UTF-8 #define STRINGIZE(x) #x #define EXPAND(x) STRINGIZE(x) LANGUAGE LANG_NEUTRAL, SUBLANG_NEUTRAL CREATEPROCESS_MANIFEST_RESOURCE_ID RT_MANIFEST manifest.xml 10 ICON EXPAND(APP_ICO) VS_VERSION_INFO VERSIONINFO FILEVERSION VERSION_ARRAY PRODUCTVERSION VERSION_ARRAY FILEFLAGSMASK VS_FFI_FILEFLAGSMASK FILEFLAGS 0x0 FILEOS VOS__WINDOWS32 FILETYPE VFT_APP FILESUBTYPE VFT2_UNKNOWN BEGIN BLOCK &amp;#34;StringFileInfo&amp;#34; BEGIN BLOCK &amp;#34;080404B0&amp;#34; BEGIN VALUE &amp;#34;CompanyName&amp;#34;, &amp;#34;Your Company&amp;#34; VALUE &amp;#34;FileDescription&amp;#34;, &amp;#34;Example&amp;#34; VALUE &amp;#34;FileVersion&amp;#34;, EXPAND(VERSION_STR) VALUE &amp;#34;InternalName&amp;#34;, &amp;#34;Example&amp;#34; VALUE &amp;#34;LegalCopyright&amp;#34;, &amp;#34;© example&amp;#34; VALUE &amp;#34;OriginalFilename&amp;#34;, &amp;#34;example.</description></item><item><title>Git 备忘</title><link>https://xhat.org/posts/git-remind/</link><pubDate>Sun, 16 Jan 2022 15:22:17 +0800</pubDate><guid>https://xhat.org/posts/git-remind/</guid><description>设置用户信息 git config --global --list # 用户 git config --global user.name &amp;#34;your-name&amp;#34; git config --global user.email user@example.com # GPG 签名 git config --global user.signingkey XXXXXX 克隆仓库 git clone https://github.com/xxx/x.git 有子模块的：
git clone --recursive https://github.com/xxx/x.git 标签 删除本地标签 git tag --delete tagname 删除远程标签 git push --delete origin tagname</description></item></channel></rss>