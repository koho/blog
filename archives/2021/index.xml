<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>2021 on Xhat Blog</title><link>https://blog.xhat.io/archives/2021/</link><description>Recent content in 2021 on Xhat Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 14 Dec 2021 00:09:32 +0800</lastBuildDate><atom:link href="https://blog.xhat.io/archives/2021/index.xml" rel="self" type="application/rss+xml"/><item><title>Linux 部署 Nginx</title><link>https://blog.xhat.io/posts/linux-nginx-deploy/</link><pubDate>Tue, 14 Dec 2021 00:09:32 +0800</pubDate><guid>https://blog.xhat.io/posts/linux-nginx-deploy/</guid><description>安装 参考官网的安装文档。
静态网站 # 强制跳转HTTPS server { listen 80; server_name example.com; return 301 https://$http_host$request_uri; } server { listen 443 ssl http2; ssl_certificate /etc/example.com.crt; ssl_certificate_key /etc/example.com.key; ssl_protocols TLSv1.3 TLSv1.2; server_name example.com; #access_log /var/log/nginx/host.access.log main; location / { root /usr/share/app/html; index index.html index.htm; } #error_page 404 /404.html; error_page 497 https://$http_host$request_uri; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; } } 代理网站 server{ listen 8888 ssl http2; listen [::]:8888 ssl http2; ssl_certificate /etc/example.</description></item><item><title>Golang 程序以 Windows 服务运行</title><link>https://blog.xhat.io/posts/golang-windows-service/</link><pubDate>Fri, 12 Nov 2021 13:15:06 +0800</pubDate><guid>https://blog.xhat.io/posts/golang-windows-service/</guid><description>Windows 服务是运行后台程序的一个很好的选择，可以支持开机自动启动，程序异常退出后自动重启这些实用功能。
Windows 服务程序有一套自己的机制。如果你不想在你的程序添加任何代码的话，有一些工具可以直接把可执行程序作为 Windows 服务运行，比如 winsw。
本文介绍的是在 Go 中制作自己的服务程序，主要使用的是 golang.org/x/sys/windows/svc 这个包。正如文档所说，实现Handler接口即可，当服务启动时，会调用Execute方法。
type demoService struct { } func (service *demoService) Execute(args []string, r &amp;lt;-chan svc.ChangeRequest, changes chan&amp;lt;- svc.Status) (svcSpecificEC bool, exitCode uint32) { changes &amp;lt;- svc.Status{State: svc.StartPending} defer func() { changes &amp;lt;- svc.Status{State: svc.StopPending} log.Println(&amp;#34;Shutting down&amp;#34;) }() // 要执行的主程序代码 go yourMainFunc() changes &amp;lt;- svc.Status{State: svc.Running, Accepts: svc.AcceptStop | svc.AcceptShutdown} log.Println(&amp;#34;Startup complete&amp;#34;) for { select { case c := &amp;lt;-r: switch c.</description></item><item><title>Golang 在 Windows 下防止程序多开</title><link>https://blog.xhat.io/posts/golang-gui-singleton/</link><pubDate>Mon, 11 Oct 2021 11:02:41 +0800</pubDate><guid>https://blog.xhat.io/posts/golang-gui-singleton/</guid><description>当用户运行多个程序实例，如果操作的是同一资源，可能会造成数据不一致。所以有一个防止多开的需求，原理上是利用 CreateMutex 这个函数创建互斥对象。
func checkSingleton() (windows.Handle, error) { path, err := os.Executable() if err != nil { return 0, err } hashName := md5.Sum([]byte(path)) name, err := syscall.UTF16PtrFromString(&amp;#34;Local\\&amp;#34; + hex.EncodeToString(hashName[:])) if err != nil { return 0, err } return windows.CreateMutex(nil, false, name) } 检查error，如果是syscall.ERROR_ALREADY_EXISTS，则说明有一个程序已经在运行。
上面创建的互斥对象是局部的(有Local前缀)，多个用户登录还是可以同时多开程序的。如果需要全局限制，则替换为Global前缀。如果你的程序以服务的形式运行，则可能需要设置互斥对象的权限。
func checkSingleton() (windows.Handle, error) { path, err := os.Executable() if err != nil { panic(err) } hashName := md5.Sum([]byte(path)) name, err := syscall.UTF16PtrFromString(&amp;#34;Global\\&amp;#34; + hex.</description></item><item><title>Linux 部署 WireGuard</title><link>https://blog.xhat.io/posts/linux-wireguard/</link><pubDate>Fri, 03 Sep 2021 14:33:27 +0800</pubDate><guid>https://blog.xhat.io/posts/linux-wireguard/</guid><description>安装 CentOS sudo yum install epel-release elrepo-release sudo yum install yum-plugin-elrepo sudo yum install kmod-wireguard wireguard-tools Ubuntu sudo apt install wireguard 若内核太老不想升级，可以使用 wireguard-go 代替。
配置 创建 Wireguard 目录： mkdir /etc/wireguard/ cd /etc/wireguard/ 生成密钥对 wg genkey | tee privatekey | wg pubkey &amp;gt; publickey 编辑配置文件 vi wg0.conf 内容模板：
[Interface] Address = 10.100.100.3/32 PrivateKey = KEY ListenPort = 21841 PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE [Peer] PublicKey = PUB Endpoint = IP AllowedIPs = 10.</description></item><item><title>Golang 打开 Windows 服务属性窗口</title><link>https://blog.xhat.io/posts/golang-service-property/</link><pubDate>Sun, 01 Aug 2021 11:35:17 +0800</pubDate><guid>https://blog.xhat.io/posts/golang-service-property/</guid><description>本文介绍如何在 Golang 程序里面打开某个 Windows 服务的属性窗口，这里需要用到 COM 接口，详细文档请参考 MMC 2.0 的官方文档。
既然是 COM 的话，程序里也可以使用cmd或者powershell来调用 COM 打开服务窗口。下面介绍直接调用 COM 组件的方法：
使用 github.com/go-ole/go-ole 这个库调用 COM：
import ( &amp;#34;github.com/go-ole/go-ole&amp;#34; &amp;#34;github.com/go-ole/go-ole/oleutil&amp;#34; &amp;#34;time&amp;#34; ) // 服务的显示名称 displayName := &amp;#34;Windows Update&amp;#34; ole.CoInitialize(0) unknown, _ := oleutil.CreateObject(&amp;#34;MMC20.Application&amp;#34;) mmc, _ = unknown.QueryInterface(ole.IID_IDispatch) // 读取服务 oleutil.MustCallMethod(mmc, &amp;#34;Load&amp;#34;, &amp;#34;services.msc&amp;#34;) document := oleutil.MustGetProperty(mmc, &amp;#34;Document&amp;#34;).ToIDispatch() view := oleutil.MustGetProperty(document, &amp;#34;ActiveView&amp;#34;).ToIDispatch() list := oleutil.MustGetProperty(view, &amp;#34;ListItems&amp;#34;).ToIDispatch() count := int(oleutil.MustGetProperty(list, &amp;#34;Count&amp;#34;).Val) // 注意索引从1开始 for i := 1; i &amp;lt;= count; i++ { item := oleutil.</description></item><item><title>Windows 创建临时文件</title><link>https://blog.xhat.io/posts/windows-createfile-tempfile/</link><pubDate>Mon, 19 Jul 2021 09:36:38 +0800</pubDate><guid>https://blog.xhat.io/posts/windows-createfile-tempfile/</guid><description>在 Windows 上希望创建一个临时文件，该文件在程序退出时自动删除，即使是被强制停止的。这时需要使用 CreateFile 这个函数：
HANDLE CreateFileA( [in] LPCSTR lpFileName, // 指向文件名的指针 [in] DWORD dwDesiredAccess, // 访问模式，写/读 [in] DWORD dwShareMode, // 共享模式 [in, optional] LPSECURITY_ATTRIBUTES lpSecurityAttributes, // 指向安全属性的指针 [in] DWORD dwCreationDisposition, // 如何创建 [in] DWORD dwFlagsAndAttributes, // 文件属性 [in, optional] HANDLE hTemplateFile // 用于复制文件句柄 ); 重点关注dwShareMode和dwFlagsAndAttributes这两个参数。
共享模式dwShareMode有四种选项，分别为
0：禁止其他进程进行删除、读取和写入 FILE_SHARE_DELETE：允许删除 FILE_SHARE_READ：允许读取 FILE_SHARE_WRITE：允许写入 文件属性dwFlagsAndAttributes需要设定两项：
FILE_ATTRIBUTE_TEMPORARY：该文件为临时文件，尽可能使用内存缓存，避免写入磁盘。 FILE_FLAG_DELETE_ON_CLOSE：当所有句柄被关闭时，立刻删除文件。 实验：
h, _ := windows.CreateFile( windows.StringToUTF16Ptr(&amp;#34;tmp&amp;#34;), windows.GENERIC_WRITE, windows.FILE_SHARE_READ, nil, windows.OPEN_ALWAYS, windows.FILE_ATTRIBUTE_TEMPORARY|windows.FILE_FLAG_DELETE_ON_CLOSE, 0, ) var done uint32 windows.</description></item><item><title>Python 进行 ARP 欺骗</title><link>https://blog.xhat.io/posts/python-arpspoof/</link><pubDate>Wed, 09 Jun 2021 18:27:39 +0800</pubDate><guid>https://blog.xhat.io/posts/python-arpspoof/</guid><description>声明：本文所用的脚本仅限于学习测试目的，在使用中造成的一切后果与作者无关，后果自负。
ARP (Address Resolution Protocol) 即地址解析协议，是一种将 IP 地址转化成物理地址的协议。我们常用的以太网是通过 MAC 地址进行通信的，所以在网络链路上传送数据帧时，最终是使用硬件地址的。
一个典型的 ARP 流程如下表所示，这里为了叙述方便，硬件地址做了简化处理。
源地址 目的地址 内容 12:34:56 ff:ff:ff Who has 192.168.1.2? Tell 192.168.1.3 78:ab:cd 12:34:56 192.168.1.2 is at 78:ab:cd 大致流程就是12:34:56发送一个广播，问谁有某个 IP 地址，当对方收到这个广播时，如果自己的 IP 和广播里问的 IP 是一致的，就发送一个回复给提问者。这样提问者就建立了 IP 地址和物理地址的对应关系。
那如果对方不守信呢，明明自己没有这个 IP，还是坚持回复这个 IP 是自己，欺骗了提问者。这时提问者就会把数据包发给其他人，相当于数据包被人偷了！
没错，ARP 欺骗就是这个原理，可以用来做中间人攻击和拒绝服务攻击。下面分别实验一下两种情况。
网关 IP：10.1.45.254
受害者 IP：10.1.45.2
中间人攻击 欺骗受害者网关在我们这里，受害者就会把数据包发给我们，我们再代为转发给真正的网关，相当于做了一个中间人，这时我们可以捕获到受害者的通信数据包。
# arpspoof.py import sys from scapy.layers.l2 import Ether, ARP, sendp from scapy.layers.l2 import getmacbyip if __name__ == &amp;#39;__main__&amp;#39;: if len(sys.</description></item><item><title>Golang 中使用 JWT 进行认证</title><link>https://blog.xhat.io/posts/golang-jwt/</link><pubDate>Mon, 10 May 2021 13:19:47 +0800</pubDate><guid>https://blog.xhat.io/posts/golang-jwt/</guid><description>JSON Web Token (JWT) 是一种目前流行的跨域认证方案，JWT 是基于 JSON 的经过签名的 Token，可以在进行验证的同时附带身份信息，保证传输的信息没有被修改，对于前后端分离项目很有帮助。
JSON Web Token (JWT) 是一个开放标准 (RFC 7519)，它定义了一种紧凑的、自包含的方式，用于作为 JSON 对象在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。
原理 JWT 的认证流程是，用户登录成功后，服务端生成一个 JWT 格式的 Token，发回给用户，这个 Token 包含了用于标记用户的信息，此后用户与服务端通信时，都携带这个 Token，服务端就能靠这个 Token 确定用户的身份。
如上面提到，这个 Token 是有签名的，所以可以保证数据不被篡改，是值得信任的。
JWT 由三部分组成，它们之间用圆点(.)相连。分别为：
Header（头部） Payload（负载） Signature（签名） 最后生成的字符串大概就是这样子的：
xxx.yyy.zzz 下面简单说一下这三个部分。
Header 头部主要用来描述一些元数据。
{ &amp;#34;alg&amp;#34;: &amp;#34;HS256&amp;#34;, &amp;#34;typ&amp;#34;: &amp;#34;JWT&amp;#34; } 主要就包含这两个字段，alg是所使用的签名算法，服务端会使用该算法签名或验证 Token，typ就是类型了，固定为JWT。
最后使用 Base64URL 算法把这个 JSON 对象转换为字符串。
可以看到这部分是没有加密的，所以不要放置敏感信息。
Payload 负载部分用来存放实际传递的数据，也就是关于用户的数据，JWT 官方提供了七个预定义的字段：
{ &amp;#34;iss&amp;#34;: &amp;#34;签发人&amp;#34;, &amp;#34;exp&amp;#34;: &amp;#34;过期时间&amp;#34;, &amp;#34;sub&amp;#34;: &amp;#34;主题&amp;#34;, &amp;#34;aud&amp;#34;: &amp;#34;受众&amp;#34;, &amp;#34;nbf&amp;#34;: &amp;#34;生效时间&amp;#34;, &amp;#34;iat&amp;#34;: &amp;#34;签发时间&amp;#34;, &amp;#34;jti&amp;#34;: &amp;#34;编号&amp;#34; } 除此之外，我们可以自己定义需要的字段：</description></item><item><title>Python 发送 Email 通知</title><link>https://blog.xhat.io/posts/python-send-email/</link><pubDate>Tue, 20 Apr 2021 01:36:21 +0800</pubDate><guid>https://blog.xhat.io/posts/python-send-email/</guid><description>感觉没什么好说的，代码看一眼就明了，当备忘吧。
import smtplib from email.header import Header from email.mime.text import MIMEText from email.utils import formataddr def send_email(subject, text, receiver): message = MIMEText(text, &amp;#39;plain&amp;#39;, &amp;#39;utf-8&amp;#39;) message[&amp;#39;From&amp;#39;] = formataddr((&amp;#34;发送人名字&amp;#34;, &amp;#39;发送人账号&amp;#39;)) message[&amp;#39;To&amp;#39;] = formataddr((&amp;#34;&amp;#34;, receiver)) message[&amp;#39;Subject&amp;#39;] = Header(subject, &amp;#39;utf-8&amp;#39;) smtp = smtplib.SMTP_SSL(&amp;#34;SMTP 服务器&amp;#34;, 465) smtp.login(&amp;#34;发送人账号&amp;#34;, &amp;#34;客户端密码&amp;#34;) smtp.sendmail(&amp;#39;发送人账号&amp;#39;, receiver, message.as_string()) smtp.quit()</description></item><item><title>Golang 使用 Casbin 进行权限管理</title><link>https://blog.xhat.io/posts/golang-casbin/</link><pubDate>Thu, 04 Mar 2021 01:18:53 +0800</pubDate><guid>https://blog.xhat.io/posts/golang-casbin/</guid><description>先说需求，设计一个基于角色的权限控制系统，满足以下几个规则：
单独配置某个角色对某个资源的访问权限 一个用户可拥有多个角色 可对角色进行禁用或启用 各个角色之间的权限为并集，且只要有一个角色有权限，该用户就有权限操作 可对一个菜单下的某些重要功能做单独控制，当用户有该菜单的访问权限，没有功能访问权限时，依然能访问该菜单下的非功能接口 Casbin 是一个强大的、高效的开源访问控制框架，其权限管理机制支持多种访问控制模型。
具体支持的模型官网有详细描述，回到本例应该使用的模型是RBAC (基于角色的访问控制)。
Casbin使用配置文件来设置访问控制模式。它有两个配置文件，model.conf和policy.csv。 其中，model.conf存储了访问模型，policy.csv存储了特定的用户权限配置。
模型 Casbin 将访问控制模型抽象为基于PERM(Policy, Effect, Request, Matcher)的一个文件，分别为：
策略 效果 请求 匹配器 基于角色的访问控制需要在此基础上加多一个role_definition进行角色的定义。
请求(request_definition) 该部分用于请求的定义，经典的三元组：访问实体 (Subject)，访问资源 (Object) 和访问方法 (Action)，也可以根据自己的需求进行增加或删除字段。后端常用的控制请求就是uid, /api/res1, GET。
[request_definition] r = sub, obj, act 策略(policy_definition) 该部分定义控制策略的模板，哪个实体对哪个资源有怎样的权限。注意：这里的sub, obj不一定需要与请求里面的值一致，具体怎样匹配是匹配器定义的。例如这里的一条策略可以是alice, res1, allow。
[policy_definition] p = sub, obj, eft 角色定义(role_definition) 该部分定义了角色系统，用户可以具有角色及其继承关系, 资源也可以具有角色及其继承关系。 这两个 RBAC 系统不会互相干扰。这里我使用了三个角色系统：g是用户和角色的从属关系；g2是资源的从属关系；g3是角色的开关。
[role_definition] g = _, _ g2 = _, _, _ g3 = _, _ 举个例子，g可以是user_1, 1，表示uid是 1 的用户拥有角色 1。g2可以理解为将多个接口组成一个资源组，角色拥有该资源组的权限则有这些接口的访问权限。</description></item><item><title>OpenWrt + Pon Stick 配置教程</title><link>https://blog.xhat.io/posts/openwrt-pon-stick/</link><pubDate>Sat, 06 Feb 2021 14:00:28 +0800</pubDate><guid>https://blog.xhat.io/posts/openwrt-pon-stick/</guid><description>0x1 配置访问模块 首先确定模块插在哪个接口，本例中模块接在eth1上。确定模块IP，本例为192.168.1.1。下面配置一个接口，使内网的机器能直接访问模块。
若OpenWrt的地址也是192.168.1.1，需要修改地址： 在网络-&amp;gt;接口页面，编辑LAN接口，把IP地址改为172.20.0.1(其他网段亦可)。
新建一个接口，名字为PON，协议为静态IP，接口为eth1。 配置IP地址为192.168.1.2，子网掩码为255.255.255.252.
在防火墙设置选项卡里选择分配给wan，
后续就可以访问模块地址进行配置，请参考模块配置教程。
0x2 拨号 这部分已经假定模块已经配置完成，并完成光路认证。还需要确定VLAN ID，一般在光猫的后台可以看到：
在上网的连接名称可以看到后面的VID_41，41就是上网的VLAN ID。
回到OpenWrt页面，编辑WAN接口(没有的新建一个)，协议选择PPPoE，用户名密码照常输入，防火墙分配给wan. 要注意的是在物理设置选择接口那里，下拉到最后，在自定义输入框里输入eth1.41, eth1是模块所在的接口，41是上面的上网VLAN ID。
后续应该就可以正常拨号上网了。</description></item><item><title>OpenWrt 网关抓包</title><link>https://blog.xhat.io/posts/openwrt-trafficdump/</link><pubDate>Fri, 08 Jan 2021 11:26:10 +0800</pubDate><guid>https://blog.xhat.io/posts/openwrt-trafficdump/</guid><description>把 WireShark 添加到环境变量 OpenWrt 安装 tcpdump 执行命令:
ssh root@openwrt tcpdump -s 0 -U -n -w - -i eth1 not port 22 | wireshark -k -i - 注意将eth1替换为你实际需要捕获的接口。</description></item></channel></rss>